// -*- mode: Swift -*-

// AUTOGENERATED BY glean_parser.  DO NOT EDIT.

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

// swiftlint:disable superfluous_disable_command
// swiftlint:disable nesting
// swiftlint:disable line_length
// swiftlint:disable identifier_name
// swiftlint:disable force_try

extension GleanMetrics {
    enum GleanBaseline {
        /// The duration of the last foreground session.
        static let duration = TimespanMetricType(
            category: "glean.baseline",
            name: "duration",
            sendInPings: ["baseline"],
            lifetime: .ping,
            disabled: false,
            timeUnit: .second
        )

    }

    enum GleanInternalMetrics {
        /// The name of the operating system.
        /// Possible values:
        /// Android, iOS, Linux, Darwin, Windows,
        /// FreeBSD, NetBSD, OpenBSD, Solaris, unknown
        static let os = StringMetricType(
            category: "",
            name: "os",
            sendInPings: ["glean_client_info"],
            lifetime: .application,
            disabled: false
        )

        /// The user-visible version of the operating system (e.g. "1.2.3"). If the
        /// version detection fails, this metric gets set to `Unknown`.
        static let osVersion = StringMetricType(
            category: "",
            name: "os_version",
            sendInPings: ["glean_client_info"],
            lifetime: .application,
            disabled: false
        )

        /// The manufacturer of the device the application is running on.
        /// Not set if the device manufacturer can't be determined (e.g. on Desktop).
        static let deviceManufacturer = StringMetricType(
            category: "",
            name: "device_manufacturer",
            sendInPings: ["glean_client_info"],
            lifetime: .application,
            disabled: false
        )

        /// The model of the device the application is running on.
        /// On Android, this is Build.MODEL, the user-visible marketing name,
        /// like "Pixel 2 XL".
        /// Not set if the device model can't be determined (e.g. on Desktop).
        static let deviceModel = StringMetricType(
            category: "",
            name: "device_model",
            sendInPings: ["glean_client_info"],
            lifetime: .application,
            disabled: false
        )

        /// The architecture of the device, (e.g. "arm", "x86").
        static let architecture = StringMetricType(
            category: "",
            name: "architecture",
            sendInPings: ["glean_client_info"],
            lifetime: .application,
            disabled: false
        )

        /// A UUID uniquely identifying the client.
        static let clientId = UuidMetricType(
            category: "",
            name: "client_id",
            sendInPings: ["glean_client_info"],
            lifetime: .user,
            disabled: false
        )

        /// The build identifier generated by the CI system (e.g. "1234/A").
        /// For language bindings that provide automatic detection for this value,
        /// (e.g. Android/Kotlin), in the unlikely event that the build identifier
        /// can not be retrieved from the OS, it is set to "inaccessible". For other
        /// language bindings, if the value was not provided through configuration,
        /// this metric gets set to `Unknown`.
        static let appBuild = StringMetricType(
            category: "",
            name: "app_build",
            sendInPings: ["glean_client_info"],
            lifetime: .application,
            disabled: false
        )

        /// The user visible version string (e.g. "1.0.3").
        /// 
        /// In the unlikely event that the display version can not be retrieved,
        /// it is set to "inaccessible".
        static let appDisplayVersion = StringMetricType(
            category: "",
            name: "app_display_version",
            sendInPings: ["glean_client_info"],
            lifetime: .application,
            disabled: false
        )

        /// The channel the application is being distributed on.
        static let appChannel = StringMetricType(
            category: "",
            name: "app_channel",
            sendInPings: ["glean_client_info"],
            lifetime: .application,
            disabled: false
        )

        /// The date of the first run of the application.
        static let firstRunDate = DatetimeMetricType(
            category: "",
            name: "first_run_date",
            sendInPings: ["glean_client_info"],
            lifetime: .user,
            disabled: false,
            timeUnit: .day
        )

        /// The locale of the application during initialization (e.g. "es-ES").
        /// If the locale can't be determined on the system, the value is
        /// ["und"](https://unicode.org/reports/tr35/#Unknown_or_Invalid_Identifiers),
        /// to indicate "undetermined".
        static let locale = StringMetricType(
            category: "",
            name: "locale",
            sendInPings: ["glean_client_info"],
            lifetime: .application,
            disabled: false
        )

        /// The optional reason the ping was submitted.
        /// The specific values for reason are specific to each ping, and are
        /// documented in the ping's pings.yaml file.
        static let pingReason = StringMetricType(
            category: "",
            name: "ping_reason",
            sendInPings: ["metrics"],
            lifetime: .ping,
            disabled: false
        )

    }

    enum GleanError {
        private static let invalidValueLabel = CounterMetricType(
            category: "glean.error",
            name: "invalid_value",
            sendInPings: ["all-pings"],
            lifetime: .ping,
            disabled: false
        )

        /// Counts the number of times a metric was set to an invalid value.
        /// The labels are the `category.name` identifier of the metric.
        static let invalidValue = try! LabeledMetricType<CounterMetricType>(
            category: "glean.error",
            name: "invalid_value",
            sendInPings: ["all-pings"],
            lifetime: .ping,
            disabled: false,
            subMetric: invalidValueLabel,
            labels: nil
        )

        private static let invalidLabelLabel = CounterMetricType(
            category: "glean.error",
            name: "invalid_label",
            sendInPings: ["all-pings"],
            lifetime: .ping,
            disabled: false
        )

        /// Counts the number of times a metric was set with an invalid label.
        /// The labels are the `category.name` identifier of the metric.
        static let invalidLabel = try! LabeledMetricType<CounterMetricType>(
            category: "glean.error",
            name: "invalid_label",
            sendInPings: ["all-pings"],
            lifetime: .ping,
            disabled: false,
            subMetric: invalidLabelLabel,
            labels: nil
        )

        private static let invalidStateLabel = CounterMetricType(
            category: "glean.error",
            name: "invalid_state",
            sendInPings: ["all-pings"],
            lifetime: .ping,
            disabled: false
        )

        /// Counts the number of times a timing metric was used incorrectly.
        /// The labels are the `category.name` identifier of the metric.
        static let invalidState = try! LabeledMetricType<CounterMetricType>(
            category: "glean.error",
            name: "invalid_state",
            sendInPings: ["all-pings"],
            lifetime: .ping,
            disabled: false,
            subMetric: invalidStateLabel,
            labels: nil
        )

        private static let invalidOverflowLabel = CounterMetricType(
            category: "glean.error",
            name: "invalid_overflow",
            sendInPings: ["all-pings"],
            lifetime: .ping,
            disabled: false
        )

        /// Counts the number of times a metric was set a value that overflowed.
        /// The labels are the `category.name` identifier of the metric.
        static let invalidOverflow = try! LabeledMetricType<CounterMetricType>(
            category: "glean.error",
            name: "invalid_overflow",
            sendInPings: ["all-pings"],
            lifetime: .ping,
            disabled: false,
            subMetric: invalidOverflowLabel,
            labels: nil
        )

        /// The number of tasks queued in the pre-initialization buffer.
        /// Only sent if the buffer overflows.
        static let preinitTasksOverflow = CounterMetricType(
            category: "glean.error",
            name: "preinit_tasks_overflow",
            sendInPings: ["metrics"],
            lifetime: .ping,
            disabled: false
        )

    }

    enum GleanUpload {
        private static let pingUploadFailureLabel = CounterMetricType(
            category: "glean.upload",
            name: "ping_upload_failure",
            sendInPings: ["metrics"],
            lifetime: .ping,
            disabled: false
        )

        /// Counts the number of ping upload failures, by type of failure.
        /// This includes failures for all ping types,
        /// though the counts appear in the next successfully sent `metrics` ping.
        static let pingUploadFailure = try! LabeledMetricType<CounterMetricType>(
            category: "glean.upload",
            name: "ping_upload_failure",
            sendInPings: ["metrics"],
            lifetime: .ping,
            disabled: false,
            subMetric: pingUploadFailureLabel,
            labels: ["recoverable", "status_code_4xx", "status_code_5xx", "status_code_unknown", "unrecoverable"]
        )

        /// The size of pings that exceeded the maximum ping size allowed for upload.
        static let discardedExceedingPingsSize = MemoryDistributionMetricType(
            category: "glean.upload",
            name: "discarded_exceeding_pings_size",
            sendInPings: ["metrics"],
            lifetime: .ping,
            disabled: false,
            memoryUnit: .kilobyte
        )

        /// The size of the pending pings directory upon initialization of Glean. This does
        /// not include the size of the deletion request pings directory.
        static let pendingPingsDirectorySize = MemoryDistributionMetricType(
            category: "glean.upload",
            name: "pending_pings_directory_size",
            sendInPings: ["metrics"],
            lifetime: .ping,
            disabled: false,
            memoryUnit: .kilobyte
        )

        /// The number of pings deleted after the quota for the size of the pending pings
        /// directory is hit. Since quota is only calculated for the pending pings
        /// directory, and deletion request ping live in a different directory, deletion
        /// request pings are never deleted.
        static let deletedPingsAfterQuotaHit = CounterMetricType(
            category: "glean.upload",
            name: "deleted_pings_after_quota_hit",
            sendInPings: ["metrics"],
            lifetime: .ping,
            disabled: false
        )

    }

    enum GleanDatabase {
        /// The size of the database file at startup.
        static let size = MemoryDistributionMetricType(
            category: "glean.database",
            name: "size",
            sendInPings: ["metrics"],
            lifetime: .ping,
            disabled: false,
            memoryUnit: .byte
        )

    }

    class Pings {
        public static let shared = Pings()
        private init() {
            // Intentionally left private, no external user can instantiate a new global object.
        }

        enum BaselineReasonCodes: Int, ReasonCodes {
            case background = 0
            case dirtyStartup = 1
            case foreground = 2

            public func index() -> Int {
                return self.rawValue
            }
        }

        /// This ping is intended to provide metrics that are managed by the library
        /// itself, and not explicitly set by the application or included in the
        /// application's `metrics.yaml` file.
        /// The `baseline` ping is automatically sent when the application is moved to
        /// the background.
        let baseline = Ping<BaselineReasonCodes>(
            name: "baseline",
            includeClientId: true,
            sendIfEmpty: true,
            reasonCodes: ["background", "dirty_startup", "foreground"]
        )

        enum MetricsReasonCodes: Int, ReasonCodes {
            case overdue = 0
            case reschedule = 1
            case today = 2
            case tomorrow = 3
            case upgrade = 4

            public func index() -> Int {
                return self.rawValue
            }
        }

        /// The `metrics` ping is intended for all of the metrics that are explicitly
        /// set by the application or are included in the application's `metrics.yaml`
        /// file (except events).
        /// The reported data is tied to the ping's *measurement window*, which is the
        /// time between the collection of two `metrics` ping. Ideally, this window is
        /// expected to be about 24 hours, given that the collection is scheduled daily
        /// at 4AM. Data in the `ping_info` section of the ping can be used to infer the
        /// length of this window.
        let metrics = Ping<MetricsReasonCodes>(
            name: "metrics",
            includeClientId: true,
            sendIfEmpty: false,
            reasonCodes: ["overdue", "reschedule", "today", "tomorrow", "upgrade"]
        )

        enum EventsReasonCodes: Int, ReasonCodes {
            case background = 0
            case maxCapacity = 1
            case startup = 2

            public func index() -> Int {
                return self.rawValue
            }
        }

        /// The events ping's purpose is to transport all of the event metric
        /// information. The `events` ping is automatically sent when the application is
        /// moved to the background.
        let events = Ping<EventsReasonCodes>(
            name: "events",
            includeClientId: true,
            sendIfEmpty: false,
            reasonCodes: ["background", "max_capacity", "startup"]
        )

        /// This ping is submitted when a user opts out of
        /// sending technical and interaction data to Mozilla.
        /// This ping is intended to communicate to the Data Pipeline
        /// that the user wishes to have their reported Telemetry data deleted.
        /// As such it attempts to send itself at the moment the user
        /// opts out of data collection.
        let deletionRequest = Ping<NoReasonCodes>(
            name: "deletion-request",
            includeClientId: true,
            sendIfEmpty: true,
            reasonCodes: []
        )

    }

}
